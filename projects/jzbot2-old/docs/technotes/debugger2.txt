The debugger should also be able to handle functions that evaluate alternate code, such as the args function or the (hopefully soon-to-be) store and run functions. So I'm thinking that the window that shows the current execution stack should also show a box or something to indicate groups of items that use the same source code. When an args function is run, it uses separate source code, which is then shown.

How the output should be shown is another matter, though. Maybe, for functions generated by hand instead of generated by the parser, the explanation of the function should be shown instead of the function itself.

So, it seems, then, like the server should send a particular stack frame as the description of the item the frame is at, the text of the frame, the highlight positions and colors that should show up on the text, the frame's current sink, and, if the sink implements ObservableSink, the sink's current data (up to a certain amount which can be set by the debugger, say, 2048 characters).

When debugging a particular factoid (I still haven't determined how you actually tell it that you want to debug a particular factoid), there would be three buttons: step into, step over, and step out. There would also be a continue button, which stops debugging that factoid. 

	Step over is meant for when the debug point is immediately within a sequence, or when the debug point is a function argument. It advances to the next argument or item in the sequence. In the case of functions that run a particular argument over and over again, such as {{split}}, step over merely advanced to the next resolution of the argument. These essentially skip breaking at all items at a lower level within the current debug point. In any other case (including when the current debug point is the last argument in a function to be called by the function implementation or when the debug point is the last item in a sequence), step over is the same as step out.
	
	Step out advances up one level. It essentially skips breaking at all items in the current debug point level.
	
	Step down only works when the current debug point is a sequence or a function call. It steps down into the function. 
	
So, to summarize the behavior of these three buttons with respect to the server-side code:

	Step over skips breaking at all points contained within the current debug point, up until executing the current debug point is over (IE so that step over will allow a particular argument to a function to be stopped multiple times if the function resolves the argument multiple times).
	
	Step out skips breaking at all points contained within the current debug point's parent.
	
	Step down does not skip any points. It simply advances to the next point, which always, if the current point is a non-empty sequence or function call, is within the current debug point.
	
So, FactContext holds a reference to a DebugInstance object. A DebugInstance object should not be re-used, and, to that end, a DebugSupport object is what is passed to the context, and this object is used to construct a new DebugInstance.

There is one debugger implementation included with the bot (and the Fact language itself): the Wire protocol. This is the protocol that Fact Debugger (FD) uses.

The wire protocol implementation of DebugSupport doesn't actually have any built-in support for accepting sockets; it simply knows how to communicate with an instance of ClientLink. There is an implementation of ClientLink called SocketLink, but this only knows how to talk with a socket that has already been set up; it doesn't know how to set up a server socket itself.

The wire server can be configured with an Authenticator instance. The authenticator specifies a number of text fields that the wire client user must fill out and submit back. It also specifies if any of these should be shown as password fields to mask the user's input. It can also specify some instructions to display at the top of the form. When the FD user fills out this information, it is sent back to the wire server, and the wire server hands it to the authenticator, which should return a name for the connection. The authenticator can throw an AccessDeniedException to indicate that the user did not authenticate properly.

So, onto the wire protocol itself, and its syntax.

All packets are sent encoded with an XMLEncoder.

First, the server sends a VersionPacket, with its version number. This is currently 1. The client then compares it with its local version number, and if the two don't match, it immediately disconnects and tells its user that they need to upgrade or downgrade their debugger.

After that comes the authentication exchange, detailed more in the authenticator class.

After the connection has been established, the server drops into request mode.

In request mode, the server listens for requests. The server will always reply to a request with a single response. The server can also send notifications, which are packets sent by the server without a request causing them to be sent.


























