The old RPC-based plugin system was getting too hard to do. So I'm writing a new system. This one embeds plugins directly, and allows registering extensions to allow plugins to be written in other languages besides Java. The language all of JZBot's built-in plugins will be written in is Python, which will be interpreted by Jython.

Plugins can only be loaded at startup, and they can't be unloaded. Basically, changing which plugins are currently running requires a restart. It's going to be easiest this way.

Plugins are passed a PluginContext object. The only thing this provides is information about the plugin's name, its language, etc, to the plugin itself, and some methods for logging stuff. Adding new commands, registering new protocols, installing new functions, etc, is done by calling into the relevant JZBot code the exact same as JZBot itself does. For example, to add a new command, the plugin would implement jw.jzbot.Command and then call jw.jzbot.JZBot.loadCommand(), passing in the implementation of Command.

So, implementations of PluginLanguage are responsible for almost everything related to plugins. A plugin itself can register a new language by calling jw.jzbot.plugins.PluginSystem.installLanguage(), passing an implementation of PluginLanguage.

Plugins can have dependencies. The plugin's dependencies cannot dynamically change at runtime. A plugin will not be loaded until its dependencies have been loaded. A plugin also will not be loaded until a plugin has installed support for the language the plugin is written in.

In order for this to work out, the plugin system takes a multi-pass approach to loading plugins. It makes one pass over the list of plugins that are available, loading those that are enabled and have all of their dependencies already loaded and have their language support loaded. Once it's done that, it makes another pass, doing the same thing to plugins that have not yet been loaded. It continues passing over the list of plugins like this until it made a pass without loading a single plugin. Then it checks to see if all of the plugins that are enabled have been loaded. If they have, then everything's good. If they haven't, it looks at the plugins that were enabled but failed to load on the last pass and examines the reason that they didn't load. Plugins that don't have language support won't even show up in the list, so we don't have to worry about those. If a plugin wasn't loaded because it has an unloaded dependency, and that dependency is not enabled, we issue a message indicating that a dependency is missing and needs to be installed or enabled. If a plugin wasn't loaded because it has an unloaded dependency, and that dependency is enabled but has not itself been loaded, then we recursively check to see why it failed to load on the last pass. If we find a similar missing-plugin siuation, we indicate an error message saying that an indirectly-dependent plugin (and we specify its name) needs to be installed or activated. If, during this recursion, we encounter a plugin we already checked, we stop and issue an error message that the plugin failed to load because of a circular dependency (and we print out all of the plugins along that dependency loop).

The plugin system hands the plugin language implementation the folder to look for plugins in, and tells it to get a list of all of the plugins in there. It does this for each pass, so that plugins that are now available due to language support being installed by a plugin will be properly loaded.

A side effect of this is that it's not even possible to see if a plugin exists unless its language support plugin is active. This isn't the best of things, but I think it's ok for now.