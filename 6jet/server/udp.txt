This is an idea I just had for speeding up communications.

One problem that I've been having that I wasn't expecting is that tcp packets are being buffered up to about one half of a second, even when flush is called on the socket output stream. I've verified that this is an issue with sockets, not with object output stream or some other facility that I'm using along the way. This causes some small ui problems.

My idea for a solution to this is that each end of communication listens over udp too. When a packet is to be sent by the packet spooler, it is sent over udp and then over tcp. The receiving ends, then, maintain a list of the last three or so packet ids received, and disregard any packets that arrive twice. This would occur when a packet goes through on udp and then arrives over tcp.

So here's how I think it should be implemented. This adds another two threads per client, but it would be worth it if it speeds things up like I think it will.

The main controller handler thread is modified to be a processing-only thread after the initial login information is received. When a username and password are successfully received from the tcp object input stream, a token (in the form of a long) is generated and added to the login response, and  a new thread that processes tcp packets is started. This thread reads off tcp packets and puts them in a blocking queue. The connectio handler thread then goes to reading from this queue, and processing each packet in it. 

The server then has one global udp thread, which listens for packets on the udp socket.