Let's see... MetaView views are described using XML. They source information from Autobus objects. As much of the view as possible should be specified in a semantic manner, although some opinion over the layout should be present.

Hmm... I'm thinking I'll try designing an example XML file for the timer program that uses layout as much as is needed and then go from there and figure out what of that needs to be changed to semantics. Or something.

So let's see... First off, I think we need a language like XPath that works for json. Such a language could be readily adapted to the model that autobus objects take.

So I searched and wasn't able to find any existing solution that's simple enough for this. It can't be this hard, though.

Although, now I'm thinking about how models should work... and how stuff should be selected from models...

Let's see... We want some sort of list element that causes children to be repeated within the container. I'm not going to add a predicate system for now; the content of a list tag will be repeated precisely once for each element in the list selected from the model, no more, no less.

It'd be nice to be able to select from a number of models as well. For example, various parts of the timer interface need to be able to source from the timers object and the startup object on the timer interface. Those are two separate models. Perhaps the same mechanism used to address attributes in objects in the model could be used to address separate models, as if there was a dictionary that contained all of the models or something.

Perhaps this global dictionary should contain keys for each model for each tag and a key called bus. This key would be a virtual dictionary whose keys represent interface names and whose values are virtual dictionaries whose keys are object names and whose values are the corresponding objects.

There should be a mechanism to predefine components in the xml file. This would allow something such as a multispinner to be created. I'm not going to worry about importing components from other xml files at present.

Separate xml components almost directly transclude their child elements into the location at which they're referenced. However, there needs to be some way to specify information to a particular component. For example, a multispinner needs to know which timer to display, what to divide the timer's seconds by, and what to mod them by.

Which is another point: the client needs to be able to perform simple equations. I'm really tempted to write a basic Fact interpreter into this whole mess, but that might put somewhat of a burden on implementations. Maybe such support could be written directly into the whole mess as xml...

Let's imagine that we're not supporting anything other than sourcing from a single model and that we're using /foo/bar as our attribute retrieval notation. Let's say we have an interface called flipflop that publishes an object named state. This interface has a function called set_state. set_state, when called, causes the state object to be set to the single value passed into the function, which must be an integer. We want to display three toggle buttons titled first, second, and third, respectively. Each of these toggle buttons appears selected when the value of the state object is 1, 2, or 3, respectively. None of the buttons will appear selected if the state object contains a value less than 1 or greater than 3. Clicking on a button calls set_state with that value. I'd imagine something like that looking thus:

<metaview model="/flipflop/state">
    <view>
        <vbox>
            <toggle display="button" state="/1" click="bus/flipflop/set_state 1"/>
            <toggle display="button" state="/2" click="bus/flipflop/set_state 2"/>
            <toggle display="button" state="/3" click="bus/flipflop/set_state 3"/>
        </vbox>
    </view>
</metaview>

That was an attempt. And it didn't go very well. Or at least I don't like how it looks. That would assume the model is actually a map containing three attributes, 1, 2, and 3, whose values are booleans. And I don't like the function invocation syntax. Let's run with this for the next 30 seconds, though, and look at the server-side code (which is in Python):

from libautobus import AutobusConnection
bus = AutobusConnection()
state_map = {1:True,2:False,3:False}
class Service(object):
    def set_state(self, new_state):
        global state_map
        state_map = dict((k, False) for k in state_map.keys())
        state_map[new_state] = True
        state_object.set(state_map)
bus.add_interface("flipflop", Service())
state_object = bus.add_object("flipflop", "state", "Some documentation here", state_map)
bus.start_connecting()

And that's it. Simple, yes. But I still don't like the look of the xml file. Actions are declared quite stupidly. How to solve that...

The problem is that the entire UI should be declarative. Avoiding anything imperative as much as possible will, in my opinion, dramatically simplify things.

We still have the problem of needing to source from multiple models. What if we introduce a concept of model dependency. Local models can be created by use of the <model> tag. These models can reference other previously-declared models or server-side autobus models. When model X references model Y, a reload sent to model Y will cause a corresponding reload of model X. Models are reloaded before any UI components are reloaded; the models required to reload are reloaded, and then the UI elements referencing those models are reloaded.

What can a local model contain, then? And where does it get stored? How is it referenced? Is it possible to declare a new model inside such as a <list>? What happens if it's referenced outside of the list? Or is it only visible inside the list? If so, what happens if it shadows a model outside of the list, and how does that work with UI element updating?

Perhaps a solution to all this is that models have to be declared outside of any UI code, meaning that, for example, there might be a <models> tag directly under the <metaview> tag in which all models have to be declared. Models can declare models underneath them that can somehow be injected into lists.

Of course, then, is there any difference between models and ordinary objects? Perhaps not. The declarative nature is still important: if a particular value changes in one location, everything should reload so as to show the updated value. Perhaps, then, we have a single <model> tag directly under <metaview> that specifies the model of the entire UI. Normally under that you'd have a <map> specifying that the model is a map. Other tags for providing information would be present, such as <int value="1"/>, <string value="hello world"/>, <true/>, <false/>, <null/>, etc. <list> would also be supported, and would construct a list containing every child element. I haven't figured out how maps would work; <map><entry><key>...</key><value>...</value></entry></map> seems overly verbose, but I'll think about it. Perhaps the most useful information-sourcing element of all, however, would be <object>. This tag is used as <object interface="flipflop" object="state"/>. As might be imagined, this sources from the specified Autobus object. Since this is all declarative, a change to that object would cause the entire model to automatically reload, which would cause all UI elements to correspondingly reload.

Of course, there's one problem where explicitly declaring identified models might come in handy: this doesn't allow for inter-referencing. Meaning, if you write one long portion of the model that needs to be used three separate times to construct other parts of the model, you've got to cut and paste it. And that's frankly annoying. That's the one argument I can see for explicit models. Or at least, some means of inter-referencing within models...

We're not supporting recursive references. I don't see any real point behind them unless you're trying to view infinitely-nested data structures in the UI... hmm, I could see something like that happening for a tree control...

I still don't think recursive references in the model generation is a good idea. Perhaps there will be something that can recursively iterate over lists containing dictionaries containing lists in the future, as a specific element. For now, though, I'm not going to worry about that. Let's see...

Gosh, this is getting slightly frustrating. What I'm thinking I'll do is add an XML layer construct into this. That is that anywhere in the entire document you can have <ref target="foo"/>. That causes the element whose id is foo, which must be defined earlier in the file and must not be an ancestor of the ref tag, to be copied verbatim into where the ref is specified. I think that should do for now. I may add a more complex inter-referencing mechanism to models later on, but I think that's good enough for now.

Oh, and there's an extra element, <refs>, that can appear directly under <metaview> before anything else including <model>. Its contents are completely ignored and can take any form that's syntactically-valid XML. The idea is that elements used purely by reference can be placed in here.

Hmm, that poses one problem: when embedding custom components, how to pass information to them. Let's skip over that for a moment. We'll come back to that in a bit.

Except... I just spotted another problem in the idea of having just one model and embedding with ref tags. That poses problems with building models with the for tag. Perhaps we should have a namespace that the file uses. Values in the namespace are simply models themselves. Instead of having a <model> tag under <metaview>, we have <models>. This can contain zero or more <model> tags which each have name attributes and which each contain exactly one element (which is one of the elements above). Any model can reference a model defined before it.

The namespacing thing will most likely simplify component inclusion too, since values can be assigned into the namespace and the component transcluded. I'll get to that in a bit.

Now, the for loop. It can be supplied with the two attributes var and in. It repeats its child elements precisely once for each item in the list selected by the in attribute, which should be a selector. During each repetition, it assigns that particular element into the namespace under the name specified by var. The for loop can also be used with attributes var1, var2, etc, and in1, in2, etc. This requires the lists selected by the in attributes to be the same length, and iterates over them all at the same time. (This is much the same as the Python statement "for var1, var2, ... in zip(in1, in2, ...): ...", but it causes an error if the input lists are not precisely the same length.)

Some additional elements are allowed in the model. <add>, <subtract>, <multiply>, and <divide> perform the specified arithmetic operations on their children. They must each contain at least two elements, and they can all contain more. When they contain more, they are all left-associative. Right now, their arguments must be integers or floating-point numbers. I'll most likely add more arithmetic operations later.

<value from=""/> can be used to include a value into a model that was declared in a previous model. The value of the from attribute is a selector.

Some conditionals are supplied. <and> and <or> are much like the arithmetic operations, but they compute the boolean and/or of their children and evaluate to a boolean. Their children can be of any type; false, 0, 0.0, the empty string, and null are all false; everything else is true. <not> must contain one child under the same constraints; its value is the boolean inverse. <equal> compares all of its children to make sure they have the same value. (I haven't decided yet whether values of different types, such as 0 and 0.0 or 0 and "0", should compare equal yet.) <greater> and <less> expect two children and compare them as expected, evaluating to a boolean value.

I'm thinking maps will be represented as <map><entry><string value="key"/><string value="value"/></entry>...</map> for now. Actually, string keys can be specified with a shorter syntax: <map><entry key="key"><string value="value"/></entry></map>. I think that should work for now.

So, let's try defining the model part of our previous flipflop example again. We're going to assume that the buttons we link to the model have some sort of state attribute that contains a selector, and the button shows as pressed if the selector selects a value and that value is true.

Oh, and, selectors are going to be of the form "name", "name/attribute", "name/attribute/attribute", etc. name is the name of a model in the namespace, and attribute is the name of an attribute on the model, which should be a map or a list if attribute is present (lists' attributes are 0, 1, etc, for items in the list). If a lookup fails for that attribute but the literal text is a valid integer value, it will be converted to such and the lookup tried again. This allows maps to use integers as their keys, which the timer server, for example, does. Any attribute name in that list can be replaced with [...], where ... is also a selector that should select a string or a number. This will be used as the name of the attribute to look up. String-to-int conversion will not be attempted for such an attribute. Selectors that don't find anything don't cause an error; they simply don't select anything. Various elements may treat this as an error condition, though, so it's important to watch out for that. A selector can also take the form "!text" or "#1"; these select precisely a string containing the value "text" and an integer containing the value 1, respectively. "?true" and "?false" select precisely the boolean values true and false as well, and "?null" selects null. I might allow "#1.0" to select a double value in the future.

<models>
    <model name="state">
        <object interface="flipflop" object="state"/>
    </model>
    <model name="buttons">
        <map>
            <entry>
                <value from="state">
                <true/>
            </entry>
        </map>
    </model>
</models>

The buttons are then specified to select from buttons/1, buttons/2, and buttons/3, respectively. Only one of those will exist, but it will correspond to the button that should be selected and its value will be true, so all is good. The other buttons won't select anything, and toggle buttons that don't select anything appear unselected, so all is good there too.

Actually, I think I'm going to include an additional optional attribute on toggle buttons specifically. That attribute is named "is". If it's present, then instead of the toggle button appearing selected when its state is true, it appears selected when its state compares equal to the value selected by the is attribute.

So far so good. Now, what about the UI itself? And what about embedding components? We're probably going to want to make it so we can customize all three buttons in one location. Let's try using custom components.

Custom components, I'm thinking, will be declared in a <components> tag below <model> and above anything else. Within this components tag can be any number of <component> tags. Each of these tags has a name specifying the component's name. Each of these should contain a single child tag representing the component. To actually include the component in the UI, you include a tag whose name is the component's name. This tag can't have any children; I'm considering adding support for custom containers later, but I'm not going to do so just yet. Attributes on this tag are set into the namespace as their specified names just before the component is included and removed just after. The value of an attribute is a selector unless it starts with an exclamation point, in which case the remainder of the value is interpreted as a string to set into the namespace. If it's a selector and it doesn't select anything, the corresponding attribute is removed from the namespace if it exists (and re-added afterward). Custom components can include any other custom component (except that I haven't yet decided whether custom components can include components defined after them).

Given this, let's try rewriting our example to display the current state. We're not going to worry about actions yet, so clicking on one of these buttons won't actually do anything. Also, most of the display attributes have been changed to be selectors instead, which should give us some flexibility in how we render the UI.

<metaview>
	<models>
		<model name="state">
			<object interface="flipflop" object="state"/>
		</model>
	</models>
	<components>
		<component name="statebutton">
			<toggle text="text" state="state" is="number"/>
		</component>
	</components>
	<view>
		<vbox>
			<statebutton text="!first" number="#1"/>
			<statebutton text="!second" number="#2"/>
			<statebutton text="!third" number="#3"/>
		</vbox>
	</view>
</metaview> 

That's actually looking pretty cool. Things are simple, too, which is good. Add some additional components and containers (vbox is a container), and you've got a nice UI that can display information. In fact, let's re-write this example to use <for> to display the buttons. The result isn't going to be quite as good as this one, but it will show how the for element can be used.

<metaview>
	<models>
		<model name="m">
			<map>
				<entry key="state">
					<object interface="flipflop" object="state">
				</entry>
				<entry key="numbers">
					<list>
						<int value="1"/>
						<int value="2"/>
						<int value="3"/>
					</list>
				</entry>
				<entry key="labels">
					<list>
						<string value="first"/>
						<string value="second"/>
						<string value="third"/>
					</list>
				</entry>
			</map>
		</model>
	</models>
	<components>
		<component name="statebutton">
			<toggle text="text" state="m/state" is="number"/>
		</component>
	</components>
	<view width="150" height="200">
		<vbox>
			<for var1="number" in1="m/numbers" var2="text" in2="m/labels">
				<statebutton/>
			</for>
		</vbox>
	</view>
</metaview>

That was quite a bit longer. In that particular case, explicitly listing each button would have been a better choice. But it serves to demonstrate how the for tag works, and more importantly, it shows that the buttons themselves could be specified in the model by replacing those two lists with <object> references (or just including them in a complete published model). This is the type of construct that the timer server will use to display each timer in its own tab and potentially in its own popped-out window. (<view> tags can be embedded in <for> lists to create a window per element.)

And speaking of that, we need to get on to actions. I should make one note here, however, that we'll be revisiting the for loop to check out identifiers, which are very important to avoid some problems with tab switching that we'd have if we simply wrote our timer program based on what we've got so far.

So, actions. This is most likely going to be the most complicated part of this whole business. Actions are how UIs actually do anything besides just show data. Probably the most common type of action would be a call to a function registered on an Autobus interface. This is what we'd use to instruct our server application to set the current state when the user presses one of the buttons. Actions can also be used for local events, however, such as showing or hiding a view, and this is precisely what the pop out button in the timer viewer will do.

So, how to invoke actions. The syntax for doing this isn't, in my opinion, going to be easy. I'm tempted to add an <action> tag that specifies how to call actions that accept arguments, which would certainly make action selection a lot easier. It would have the unfortunate effect, however, of making the action system a lot more verbose.

What if we had actions specified as "name:action arg1 arg2 arg3 ..."? name would be the name of something that accepts actions, and action would be the action to call on it. Note that names here are quite distinct from names in the model namespace. They have their own namespace, which I'm going to call the actionspace. The action can be anything that they understand. Each of the arguments is a selector, which can be surrounded by brackets if it needs to contain spaces. If a particular argument is a single : character, the arguments after that start a new action to call, so you could have multiple actions called by doing something like "name:action arg1 arg2 : anothername:anotheraction arg1".

There's an object in the actionspace named "bus" by default. It allows Autobus functions to be called. The action is of the form interface/function. For example, the "Add Timer" button in the timer viewer could have its click action be "bus:timer/create".

Of course, this doesn't deal with how to capture the return value of a function. Or even if the return value /can/ be captured. The reason we'd potentially want to capture it here is so that we can switch to the new timer's tab after the timer has been added.

We could potentially solve the timer problem by having tabbed containers add themselves into the actionspace and provide an action called something like activate_next_new that causes the tabbed pane to automatically switch to the next tab that's added to it by the model being updated. That might be the best way to go since it avoids having to synchronously wait for a function to return.

Yeah, I'm thinking that's probably the best way to go. Now, I'm thinking actions can only be referenced if they're injected into the actionspace above where they're referenced. This would allow each element to capture its view of the actionspace when it's created, which would most likely simplify things a lot. I'm not sure if it would cause any problems with <for> statements dynamically injecting elements above another element yet.

Ok, I've decided how I think this should work. Elements that support actions will have some attribute to specify the name they appear as. Certain elements cause action scopes to be created. A default action scope is present at the root view. Right now, the elements that cause new action scopes to be created are <for> and custom component tags. Only then that precludes calling actions on custom components... gah...

I'm going to go see if I can figure out how ZK handles actions...

Turns out they don't. They leave it up to a Java file that binds into the UI to handle them. Ah well, it was worth a try.

I think the main problem with searching for existing solutions is that having everything, even containers, bind to the model is a novel concept in the MVC world. Everything I've seen so far that supports MVC just supports it at the level of individual widgets for which it makes sense, such as lists or trees. Metaview extends that to make the entire system MVC, which introduces some corresponding complexities. 






































