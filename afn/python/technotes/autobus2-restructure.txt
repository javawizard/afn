So I'm thinking about restructuring some of Autobus 2.

The first bit I want to restructure is the discovery system. It knows too much about the bus at the moment; this really needs to be changed to be more along the lines of how publishers work, which is that they have essentially no knowledge of the bus. The idea is that multiple busses could use the same discoverer if that's what was desired.

So I'm thinking discoverers should have methods such as add_listener and remove_listener that add and remove listeners that listen for discovery events to happen. The listener would probably just be a function for now. It would accept parameters specifying what happened and such.

Adding a discoverer to a bus would cause the bus to add a function to the discoverer as a listener. Closing the bus would remove said listener.

I still need to figure out how to do resource management, namely how to ensure that discoverers are properly closed when they're no longer needed. Perhaps they could have a close method; Bus objects could then have a method for adding a discoverer in such a way that it would be automatically closed when the bus itself is closed.

So, the second thing I want to change is that I want services to be implemented as instances of some sort of abstract Service class. Since there's already a Service class that does other things related to services, I might call this class ServiceProvider for now.

The idea would be that a ServiceProvider provides methods for asking it what functions, events, and objects it provides. It would provide functions for actually calling service functions and functions for getting an object's value. It would also provide functions for adding/removing listeners that listen for creation of functions, adding/removing listeners that listen for event firings (and probably event creations/deletions too, for the sake of publishing their information on the introspection service), and adding/removing listeners that listen for object creation/deletion/value changes. Perhaps there might just be one type of listener that's notified when any of those things happen.

Then there would be an implementation of ServiceProvider that accepts a Python object and bases its information on that. The python object could expose traditional Python functions. It could also have instances of AutobusEvent or some such thing, which would be a callable that, when called, notifies its listeners that an event happened; the Python service provider would register listeners on all of the underlying object's events. (Perhaps the event framework should be written separate from Autobus, as it'd be useful elsewhere; I seem to recall I might have already written such a framework that could be used.) Instances of AutobusObject could also be present; this would be a class-level construct acting as a descriptor, under my current plans. Thus one could simply assign a value to the object's corresponding property, and everything would be notified correctly.

Or even better, the Python object would be required to mix in a class that would override __getattr__ and __setattr__ and handle events, functions, and objects correctly. That would allow creation of new objects and events after the service has already been published.

Then that makes me think that it might be even better to just have a mix in class that turns a plain old Python object into a service provider. The only issue is that ServiceProvider's methods would need to be named in such a way as not to conflict with methods that would be used on the actual object, which might prove difficult as that basically obviates everything not starting with an underscore.

I could, of course, break python rules and start adding double underscore methods...

It might be possible to have a __autobus_service__ method that returns a service provider object.

But then two separate objects have to be created, one that's the actual object and one that Autobus uses as the service provider. That's something I don't particularly like.

Although Python's iterator protocol has gotten away with it; you have a list, or a dict, or whatever, and then you have the iterators that iterate over it. So it might be doable.

Perhaps I should come up with an interface for service providers first, and then worry about implementing one in terms of a Python object later.

So, let's say we have these methods:

    call_function(name, args): Calls the specified function, and returns its value.
    add_listener(listener): Adds the specified listener to this service provider.
    remove_listener(listener): Removes the specified listener from this service provider.
    
Listeners would have a signature listener(event, *args), where event is one of the following constants (which would probably be in a module such as autobus2.constants):
    
    FUNCTION_ADDED: A function was added. Two arguments, name and info, will be passed. Info is a dict {"doc": ..., "type": {"args": ["int", "boolean", "any", ...], "return": "none", "remainder": null}}. I'll write more about the type dict later. NOTE THAT THE DICT PASSED MUST NOT LATER BE ALTERED; functions will typically want to assemble the dict, and the dicts it contains, when issuing FUNCTION_ADDED, or use Python's copy.deepcopy function to copy everything.
    FUNCTION_UPDATED: A function's info dict changed. Two arguments, name and info, will be passed, where info is the function's new information. The same warning present on FUNCTION_ADDED about modifications applies here.
    FUNCTION_REMOVED: A function was removed. One argument, name, is passed.
    EVENT_ADDED: An event was added. Two arguments, name and info, will be passed. Info is a dict {"doc": ..., "type": {"args": ["int", "boolean", "any", ...], "remainder": null}}.
    EVENT_UPDATED: An event's info dict changed. Two arguments, name and info, will be passed.
    EVENT_REMOVED: An event was removed. One argument, name, is passed.
    EVENT_FIRED: An event was fired. Two arguments, name and args, are passed.
    OBJECT_ADDED: An object was added. Three arguments, name, info, and value, will be passed. Info is a dict {"doc": ..., "type": "int"}.
    OBJECT_UPDATED: An object's info dict changed. Two arguments, name and info, will be passed.
    OBJECT_REMOVED: An object was removed. One argument, name, will be passed.
    OBJECT_CHANGED: An object's value changed. Two arguments, name and value, will be passed.
    SERVICE_UPDATED: A service's info dict changed. One argument, info, will be passed. Info is a dict {"doc": ...}. (This was added later; see a few paragraphs below.)

That sounds absolutely spiffing.

And in fact, most of the functionality is in the form of events issued back to the listener, with only three actual methods that the service provider needs to implement. 

So it might be feasible to break Python's rules and use double-underscore methods.

So, how about __autobus_call__, __autobus_listen__, and __autobus_unlisten__?

Then one could mix AutobusService into a Python class and get automatic __autobus_call__, __autobus_listen__, and __autobus_unlisten__ support.

That would be super awesome.

And then you just pass the object into create_service, and you're good to go.

Man, I like this a lot better than having an Autobus-managed Service class like we've got right now. Service would still be present; it'd just be a wrapper around a ServiceProvider instance that would include information like the service'd id and info dict.

So I'm trying to decide how to obtain the service's documentation...

I'm thinking that it should also be provided by the service provider, since it would typically come from the actual class's docstring, but it should be changeable, since function, event, and object docstrings can be changed as well, if the service provider wants to.

So I've just added a new event, SERVICE_UPDATED. This is used to let the service know that the doc, as reported by the service provider, has changed.

So when a listener is added with __autobus_listen__, the service provider should fire one SERVICE_UPDATED to specify the doc (which will default to None if SERVICE_UPDATED is never called), and one FUNCTION_ADDED, EVENT_ADDED, and OBJECT_ADDED for every object currently available on the service provider. These should be fired synchronously, before __autobus_listen__ returns.

Similarly, __autobus_unlisten__ should fire FUNCTION_REMOVED, EVENT_REMOVED, and OBJECT_REMOVED to remove all functions/events/objects that the listener was previously made aware of. It doesn't need to fire SERVICE_UPDATED.

This is absolutely lovely.

One note that should be obvious but is worth reiterating: a single ServiceProvider can be used with multiple services at the same time. I don't see a practical use for that right now, but I want it to be a possibility just in case.

(And I'm also thinking the future Python object implementation thingie of ServiceProvider will allow both functions assigned directly to the object instance and functions defined on the object instance's class, and will expose both as functions, with the usual Python precedence (instance overrides class) applying.)

So, when a Service is constructed, it sets up all its connection mumbo jumbo, then registers itself as a listener on the service provider passed to it. When changes happen, it updates things and sends out protocol messages as needed. When a remote tries to call a function, it passes the call to __autobus_call__.

Service handles multiple listener dispatch internally; it only ever registers one listener using __autobus_listen__ no matter how many clients there are, or so I'm thinking right now. I might change that later if I decide to do away with the Service class altogether.

So, let's go write up ServiceProvider.



Well, that was simple.









