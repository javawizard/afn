A big thing I wrote up earlier today on a modification to the new bindings system that has one binder per bindable, linking to other binders, instead of a single binder for each circuit:

Have one binder per bindable, binders are linked to each other, binder has a list of other binders it's bound to, binding two binders to each other add to each others' lists, whether or not these entries are strong or weak can be specified, validating a change against a binder passes around a list of binders that have seen that validation request thus far, same with telling a binder to receive a change, so binders tell their other binders about changes when they haven't already checked them yet, binders always have a strong reference to their bindable and vice versa, requests for values also pass things around, thus bind loops (a <-> b <-> c <-> a) can exist and are perfectly fine, and strong/weak reference semantics still work properly, bindables can change whether they're synthetic or not, concrete -> synthetic triggers a SyntheticValue change to be submitted, synthetic -> concrete just triggers the usual SetValue change, that way things like list boxes that should show up empty (or perhaps disabled) when their list of items is synthetic can be notified if they become synthetic, unbinding two binders checks both sides to see if they were concrete but just became synthetic in which case they issue a SyntheticValue change, probably validate this on both sides before actually unbinding so that the unbind can be rejected if validation fails (or maybe just require validation of a SyntheticValue to always succeed and then make annoyed faces if it doesn't), when binding two concrete binders prefer one's value as specified when binding them, when binding a synthetic binder and a concrete binder prefer the concrete binder's value and let the synthetic one know it's now concrete with a SetValue, when binding two synthetic binders don't do anything, as they both already know that they're synthetic, when binder a weak-references binder b and b goes away, check to see if that makes a synthetic and if so issue SyntheticValue, and if that fails validation then bitch loudly (same as if an ordinary desync happened, or get_value() returned a different value from the last SetValue issued, and so on, but make sure an error message is somehow printed), and then test that out by weakly binding a UI list to a memory list and drop references to the memory list and gc and see if the UI list becomes empty.
 
Array controller has three bindables, one is a concrete value bindable that holds an index into the list, one is a synthetic list bindable that is the list to consult, and one is a value bindable that holds the value at that position in the list, which is synthetic when the list bindable is synthetic and concrete when the list bindable is concrete (when it's bound to a concrete list).
 
Asking the index for its value returns our stored value. Asking the list for its value throws a SyntheticError. Asking the value for its value asks the list's binder to find its value (throwing a SyntheticError if it can't), and then returns the item at the index's value in that list (throwing some sort of bitchy exception if it's out of range, as the only way it can be out of range is if there's a desync, although I'm not sure how to deal with the case where there's no items in the list; maybe have the value be synthetic until at least one item is present). Making changes to the index checks it to make sure it's in range (throwing ValidationError if it's not) and then updates it locally. Making changes to the value ignores the change if it's synthetic, and if it's not, posts a change to the list updating the value at that index accordingly. Making changes to the list depends on what the changes are; reducing it in size past the current index will either fail validation or cause the index to be updated accordingly, not sure which yet (thinking the latter but need to make sure that doesn't cause other problems), changing a value at our current index posts a change of that value to our value bindable, changing a value at another index or adding extra items to the end of the list does nothing. I might make a separate bindable type for lists that properly track insertions as opposed to modifications and such, but that's too complicated for now. Note that this whole controller thing means we need the ability to tell a binder to issue validations and changes but omit ourselves from the process as we've already updated ourselves.
 
We could also have a controller translating between a value wrapping a list and a list itself. So it has a value bindable which is synthetic and a list bindable which is synthetic, and the value bindable's value should be another list bindable, and it keeps them in sync. So asking the list for its value asks the value's binder for its value, then gets the resulting value which is a list and asks it for its value. And asking the value for its value... does what? I think it bitches that we're synthetic right now, or something... Not sure...
 
And then telling the value that here's a list as your new value binds that list to our own list in some way, not sure exactly how to work it... Oh, if we do that we might not actually need to marshall changes among ourselves, we just need our own value which in that case might not be synthetic, and updating its value unbinds the previous value from our list-like thing we're exposing and binds its new value to that list. And our list would just be a placeholder list that is synthetic and ignores changes but serves mostly to allow things to be easily linked, basically just as a way to reference its own binder.
 
And then this value-wrapping thingie could work just fine with things of any type, not just lists, so dictionaries too.
 
So if we have a value v which contains another value which contains, say, a list, then we create one of our wrapper thingies A and bind A.value to v and create a wrapper B and bind B.value to A.list and then B.list is our underlying value, and then maybe there should be some way to validate that a bind or unbind will work without actually binding or unbinding and then we fail validation if we try to update the value of A.value to something whose value can't be validated against things bound to A.list, which would prevent v from being set to None instead of a nested value bindable.
 
So that shouldn't be too hard, as binding just checks to make sure that the side that will end up receiving a new value can validate that new value, and unbinding just checks to make sure that the side receiving a SyntheticValue change, if any, can validate it.
 
That sounds like a good start for now, and then we'll see where it goes.
 
(Also, text boxes whose values are synthetic, if text boxes don't have concrete values themselves, would just show up as disabled, although the standard way of disabling a text box would be via another value bindable called, say, enabled, whose value is a boolean.)
 
Also, have a similar thing to the array controller but that works on maps, so it has a map bindable and a value bindable and a key bindable, and the value is bound to the value of whatever key is specified. And then maybe we have a fourth value bindable that specifies a sentinel value which is used as the value bindable's value when no value exists in the map and which can be used to delete the relevant entry by setting the value to it, and trying to give us a map (or update a map after binding it to us) that has values equal to the sentinel fails validation, or maybe it just fails validation when we try to update our key that we're looking at to one that exists but is our sentinel. (Untouchable keys, so to speak.) That sounds like it'd work.
 
And then maybe a map that backs itself from a bunch of values and keys for each of those values. Needs thought on how to deal with some of the values being synthetic and others not; maybe have the keys for those values removed while they're synthetic and added back once they're not. But that'll come in a while.


