Filer is a DVCS that will be written (mainly by Alex) soonish.

It's still in the "Let's figure out what the heck this will do, and if we're even going to write it or if we'll just realize that the stuff that already exists is good enough and not even worry about it" phase.

So I just read about this vcs called Veracity that looks like it has a lot of cool features... Especially one that appears to let you apply flags to commits, such as "testing-good", "build-good", etc, which I think is /awesome/. So I'm going to take a bit and look at veracity and see what it has that filer can have too.

Haven't taken a look at it yet, but will soon.

So another feature idea I had for Filer that I think would be cool would be autosync. One would be able to do (and these commands are purely hypothetical at this point):

filer remote --enable-autopull some-remote-name

which would cause Filer to open some sort of persistent connection to the specified remote, and whenever any changes happened to that remote, they would be automatically pulled. (This would obviously require some sort of local daemon to make the connection; that bit would need more thought on how to go about doing it properly.)

That's mainly cool because 1: it gets rid of the need for people to repeatedly pull just to see if there's anything new (and I'd probably have an option for being notified of new changes without actually pulling them), and 2: it's a significant step toward allowing Filer to be used as the back-end for a future revival of OpenGroove. (OG workspaces could then use Filer to actually track their content; they would simply enable autopush and autopull and then include logic for sanely resolving merge conflicts on their own, probably by just commuting the patches into chronological order, although I could allow the user to decide... That needs more thought too.)

I don't see autopush being used as much as autopull as you typically know when you're going to do a push as it's usually after a commit, but I'll allow it for the heck of it. And because it would probably be something I'd want for OG, as then changes made while offline would be autopushed when coming online, and changes received from someone else directly could be autopushed to everyone else when they become available.

(And also, there should be a way for plugins to act as remotes of some sort, in the sense that OG would have some method for discovering other remotes over the local network and would want to somehow expose those to filer to allow autopush and autopull. Or maybe filer should have some mechanism for detecting other remotes on the local network. Or maybe that should be pluggable too. This needs more thought.)

So I don't remember if I mentioned this but I really like Veracity's notion of stamps, and it's something I want to use. Only I'm going to allow stamps as applied to particular commits to be signed. (And also, all PGP keys used to sign commits will themselves be stored in the repository, so one can look up the details of who signed a commit. I may do away with commit-based usernames and use the name stored in the corresponding PGP key instead.)

So one can say "get me all the commits in the repository stamped with tests_passed" or "get me all the commits in the repository stamped with tests_passed where said stamp was signed by 0123456789ABCDEF [the hash of a PGP key]". In other words, one should be able to address both stamps and stamps as signed by a particular PGP key as separate entities applied to a commit.

(And it should therefore be possible to stamp a commit without signing the stamp at all, and also to sign an already-existing stamp on a commit.)

As far as I'm thinking right now, stamps can't be removed. Or they can, in the same way that commits can be removed: if they're already been pushed elsewhere, they'll likely show right back up when you pull.

(The whole idea, by the way, with signing stamps is that then a central continuous integration server can stamp builds that succeed and sign said stamps, thereby allowing others to verify that the commit was stamped by the continuous integration server and not by a committer hoping to get away with code that doesn't actually pass tests.)



