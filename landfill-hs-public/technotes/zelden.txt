Going to try writing Zelden again, but this time in Haskell.

(Or at least the server will be. Haven't decided on the client yet.)

Hm, thinking I'll write a nifty little utility library first, that lets you use sockets inside STM.

Basically, it'll provide functions to "convert" a socket into a read Endpoint and a write Queue by spawning off threads to do everything. Or maybe I'll allow it to take a custom Endpoint to pull data off of and a custom Queue to put data onto.

And maybe I could even do the same thing with server sockets, have a thing that takes a Queue Handle and accepts sockets and sticks them onto the Queue. Might do that later, though, as that's not as necessary.

So, the endpoint you read from to read a socket would be an Endpoint (Maybe Packet) or something, where Nothing gets pushed across once data runs out. Might be nice, however, to give the converter an iteratee that it can use to parse data received from the socket into concrete packets and hand it to the queue that way. Or just hard-code it to push lines across; if I have Zelden be JSON-based, and require that each JSON command be on a single line, that'll sort me perfectly.

I think I'll do that for now. And then have the converter have two functions (String -> a) and (a -> String) for encoding and decoding on the socket thread before handing stuff off.

Let's try that.

Ok, done. And worked well.

So now I need to figure out how everything else is going to work.

Protocols need a way to expose things that can be configured about them. Maybe I'll just have it be a hierarchical thing like JZBot's configuration variables were.

So then each protocol exports a set of variables it needs. Each variable has a name, a description, and a type. The types, for now, I think I'll have be Text and Folder [Variable], the latter of which would allow a folder to define what variables it contains. I might also have the default value be specified in there somewhere, probably as part of the type, with folders obviously not needing a default. And maybe a validation function could be specified too, if desired.

Then each protocol would be provided with its configuration when creating connections, which would include the values of all of the variables. And whenever a variable ends up changing, a protocol would be notified.

You know what, for simplicity let's just have a set of keys and values, and they're both strings, and a protocol simply indicates a list of strings representing the keys it needs, perhaps along with default values, and then we hand the protocol a list of the keys when creating it and let it know when the user changes any of them.

We also pass some sort of Server object into each protocol that it can use to interact with us.

So Zelden starts off with no accounts. When an account is created via a client, it creates an account number and a protocol for it, and tells the protocol to start connecting, or something like that.

You know, I should take a look at lambdabot to see how it handles connections...











