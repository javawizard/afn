So this is the third generation of sixjet.

(I'm renaming it to sixjet, by the way. It used to be named 6jet; the change is mostly because things like Java packages and Python packages and such liked to throw fits at things that started with numbers, so it's just going to be easier if it's called sixjet.)

The actual fountain (and when I speak of the fountain, I mean the one that I'm putting together) will have 16 jets as currently planned. The controller board has room for expanding this to 24 jets, and I could convert the whole thing to use the old Instant Light Show boards I made, which would allow theoretically infinite expansion (with a slowdown of about a millisecond per jet state change for every additional 300 jets added, so basically not noticeable), although it would in practice be limited to around 40 jets, as I only have 10 or so boards.

(I would get others manufactured if I actually wanted to expand beyond that, though.)

So...

I've been thinking lately about rewriting Autobus 2 and making Autobus 3, which would be distributed but would clean up some of the messiness of Autobus 2. (Services, for example, would be written as instances of an abstract class Service, which would have methods such as call_function, get_function_list, get_function_doc, etc., or maybe get_function, which returns an instance of the abstract Function class, and there would be a class such as PythonObjectService that provides this functionality given a Python object, and things like that, and then local services and remote services could theoretically have an identical interface and subclass from the same class.)

But since that would take a while, I'm going to write sixjet to use Autobus 2.

So, sixjet will use Autobus 2 as its underlying protocol.

Or at least, I think...

There would be advantages to using things such as JSON-RPC for this. Probably the biggest one would be automatic Java support, as there are implementations of JSON-RPC for Java already, and I'd probably do the GUI in Java as I'm much more familiar with doing GUIs in Java than I am with doing GUIs in Python.

Hm, let me look up some things...

Ok, so, I found a lovely little library, xmlrpc.sourceforge.net, that provides a Java XML-RPC client. So what I think I'm going to do is implement sixjet to use Autobus 2, and then write a smallish tool that listens on an XML-RPC port and proxies everything over to sixjet via Autobus. Then the Java app can use that tool to communicate.

So I'm split over whether to have sixjet be one single thingie that's run on the server, or two thingies, one that's run on the server and allows jets to be controlled and one that runs elsewhere and coordinates turning jets on and off.

The first would be better for performance's sake, as there wouldn't be any network latency to slow down jet firing when music is playing and such.

The second would allow the controller to be swapped out.

Maybe I should do it as the first one, but expose functions that would allow a separate controller to be written, if one wanted to.

I'll thinking about it. For now, I'm going to implement the bit that allows jets to be remotely switched on and off.

So I've got a basic server that implements the first component of the second idea done. I've decided, though, that I'm going to use the first idea, having everything together as one thingie.

I've also decided that, for the time being, I'm going to use a native protocol instead of Autobus.

The main reason being one that I think I mentioned above, that I haven't written an Autobus library for Java yet.

But I'm thinking that I'll also provide access to most, if not all, protocol features via an Autobus service as well. (And I'm talking about Autobus 2, not Autobus 1, just to clarify.)

So connections to the server could be made through either a native protocol or through Autobus. The one with the most up-to-date features would be the native protocol, but Autobus would have most of the features as well.

(Another strong motivator for using a native protocol is that Autobus 2 doesn't yet have support for authentication; since the native protocol would, I could allow public connections to it, once I've made sure there aren't any vulnerabilities.)

The native protocol would be JSON-based, and as mentioned above, would support authentication. I'd probably allow just challenge-response password authentication (server sends client a random number, client concats it with the password and sends back the hash, server computes the same hash and checks for a match) for now.

(I might also allow authentication to just be disabled for now.)

(Or have disabled authentication be the default.)

So I've gotten eight valves put onto the valve bank so far, and all 16 relays on the controller board working. I've also got three jets and hoses hooked up and working fantastically. My family's going to be getting back from vacation in about half an hour, so I'm going to head back out and work on some more of the jets.
























