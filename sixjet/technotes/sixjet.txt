So this is the third generation of sixjet.

(I'm renaming it to sixjet, by the way. It used to be named 6jet; the change is mostly because things like Java packages and Python packages and such liked to throw fits at things that started with numbers, so it's just going to be easier if it's called sixjet.)

The actual fountain (and when I speak of the fountain, I mean the one that I'm putting together) will have 16 jets as currently planned. The controller board has room for expanding this to 24 jets, and I could convert the whole thing to use the old Instant Light Show boards I made, which would allow theoretically infinite expansion (with a slowdown of about a millisecond per jet state change for every additional 300 jets added, so basically not noticeable), although it would in practice be limited to around 40 jets, as I only have 10 or so boards.

(I would get others manufactured if I actually wanted to expand beyond that, though.)

So...

I've been thinking lately about rewriting Autobus 2 and making Autobus 3, which would be distributed but would clean up some of the messiness of Autobus 2. (Services, for example, would be written as instances of an abstract class Service, which would have methods such as call_function, get_function_list, get_function_doc, etc., or maybe get_function, which returns an instance of the abstract Function class, and there would be a class such as PythonObjectService that provides this functionality given a Python object, and things like that, and then local services and remote services could theoretically have an identical interface and subclass from the same class.)

But since that would take a while, I'm going to write sixjet to use Autobus 2.

So, sixjet will use Autobus 2 as its underlying protocol.

Or at least, I think...

There would be advantages to using things such as JSON-RPC for this. Probably the biggest one would be automatic Java support, as there are implementations of JSON-RPC for Java already, and I'd probably do the GUI in Java as I'm much more familiar with doing GUIs in Java than I am with doing GUIs in Python.

Hm, let me look up some things...

Ok, so, I found a lovely little library, xmlrpc.sourceforge.net, that provides a Java XML-RPC client. So what I think I'm going to do is implement sixjet to use Autobus 2, and then write a smallish tool that listens on an XML-RPC port and proxies everything over to sixjet via Autobus. Then the Java app can use that tool to communicate.

So I'm split over whether to have sixjet be one single thingie that's run on the server, or two thingies, one that's run on the server and allows jets to be controlled and one that runs elsewhere and coordinates turning jets on and off.

The first would be better for performance's sake, as there wouldn't be any network latency to slow down jet firing when music is playing and such.

The second would allow the controller to be swapped out.

Maybe I should do it as the first one, but expose functions that would allow a separate controller to be written, if one wanted to.

I'll thinking about it. For now, I'm going to implement the bit that allows jets to be remotely switched on and off.

So I've got a basic server that implements the first component of the second idea done. I've decided, though, that I'm going to use the first idea, having everything together as one thingie.

I've also decided that, for the time being, I'm going to use a native protocol instead of Autobus.

The main reason being one that I think I mentioned above, that I haven't written an Autobus library for Java yet.

But I'm thinking that I'll also provide access to most, if not all, protocol features via an Autobus service as well. (And I'm talking about Autobus 2, not Autobus 1, just to clarify.)

So connections to the server could be made through either a native protocol or through Autobus. The one with the most up-to-date features would be the native protocol, but Autobus would have most of the features as well.

(Another strong motivator for using a native protocol is that Autobus 2 doesn't yet have support for authentication; since the native protocol would, I could allow public connections to it, once I've made sure there aren't any vulnerabilities.)

The native protocol would be JSON-based, and as mentioned above, would support authentication. I'd probably allow just challenge-response password authentication (server sends client a random number, client concats it with the password and sends back the hash, server computes the same hash and checks for a match) for now.

(I might also allow authentication to just be disabled for now.)

(Or have disabled authentication be the default.)

So I've gotten eight valves put onto the valve bank so far, and all 16 relays on the controller board working. I've also got three jets and hoses hooked up and working fantastically. My family's going to be getting back from vacation in about half an hour, so I'm going to head back out and work on some more of the jets.

So now back to programming.

I've got some native protocol stuff written, and I've decided that there are definite advantages to doing things as an Autobus service. The biggest one is that then I don't have to go rewrite all of the socket code.

So now I'm thinking I might want to switch to Autobus and just have an XML-RPC bridge written in Python to allow the Java-based controller to connect.

And I'm thinking I need to write a lot more stuff about the design of the server before I start work on it.

I also need to think about the designer a bit.

(The designer is the app that lets you make jet firing patterns, both set to music and not set to music.)

Ok so, I wrote some notes about the designer down on my Android that I need to figure out how to copy here...

But in the mean time... Oh, found a way to share it.

So, here it is...



Publishes objects. One is a list of jet states. One is the songs in the queue (todo: add object change delta encoding to make changing this efficient). One is all the songs. Todo: decide how to do random patterns that happen when songs aren't playing; prehaps allow playlists, perhaps ones that shuffle their contents and repeat when nothing is scheduled.

Functions for turning jets on and off and for toggling and for telling the server to flash them.

Server is event-based and has a mechanism for scheduling events at times. Also allows event categories and removing events based on category. Events execute now or at a time in the future; when there are no more now events, the event queue is waited on for the nearest time-based event; events at the same time are run in the order scheduled. Flashing is done by turning on and then scheduling an event to turn off with a category of manual; switching to a song cancels all pending manual events, thus preventing flashes from screwing up the show.

Server flash time is published as an object, and there are functions for upping/downing/setting this. It's therefore the same for all clients.

Calling the clear method stops all manual events and probably also stops the current song; this probably stops media playback in some way and clear all related events.

Playback of a song schedules an event for the first jet firing. The event sets all jets that fire then and schedules an event for the next jet state change. These all have a category used to cancel them when control is returned to manual.

Music players observe objects and watch events on the server. An object specifies the current audio file; probably a hash, and then I have a server that provides files given their hash. The next few hashes would also be provided so that they can be predownloaded. An event fires every, say, five seconds to indicate where in the song the fountain is; clients that have drifted fifty ms consistently over three firings resync their audio accordingly. Maybe have this value configurable on the controller, and then it publishes it as an object and clients observe it accordingly.

Possible idea: music players publish the hashes they've downloaded, and when song N is to be played, the server says that it's to be played via the now playing object, then waits until all music players have it in their list or a certain number of seconds pass before playing. Could register a future event for N seconds to start playback, and when a remote-player-updated-download-list eveny happens and all players have music downloaded, playback starts. Manual mode cancels these events too.

Could also have players publish percent downloaded, and then controller reports global percent remaining before playback starts.

Event system should be a separate framework, maybe in afn. It should somehow integrate with autobus, or have a @run_on_event_thread decorator.

Also would be nice to announce on outside PA a few seconds before a song starts to play. Can be overridden but only by certain users. (Todo: add some sort of Autobus authentication. Maybe functions decorated such accept a session parameter, and service proxies can be told to call certain functions that modify the session on authentication. Or session is thread-local and the decoratoe gets it from the thread local and passes it in. Or something.)

So, configurable delay from request to play song until actual play song, and fire event or call function or something at attempt to play and actual start of play. Can be overridden but only by certain users. Also event indicating stop playing music.

Allow something where certain groups of songs are played in a random order. Allow certain songs to not have music. Have a configurable idle playlist that would probably be set to shuffle that plays, probably only during certain hours or when requested, when music isn't on. This could be idle mode. Manual mode switches to idle mode after a certain amount of inactivity. Idle playlist enabled on demand, or during certain times, or manual mode might only switch to idle mode at certain times and idle mode disables at the end of those times. Decide this later.

Changes to playlists and to jet firing patterns are versioned somehow. Songs, a.k.a. jet firing patterns (todo: maybe just call these patterns), can be modified remotely without having to download any files. Media server advertizes over autobus but communicates over http. Firings can be modified while playing, and the old version will be used until it's done playing. Todo: either use mercurial for this or use a custom system. Maybe have firings updated outside the system and the path to get them from configurable, and have it be a Mercurial repository for now.

Configure which playlist is the idle playlist based on time. Null playlist is allowed; does nothing.

Notion of a currently-playing playlist. Perhaps playlists can be nested, i.e. one playlist refers to another. Circular references would cause playback to stop and an error to be noted. Then we have the play queue playlist, which can have other playlists added.

Play queue can be modified from clients. Other playlists, unsure right now. Maybe they can and they're versioned in Mercurial.

Although how does that get configured based on the current time etc?

Maybe being able to change the active playlist is a good idea.

Or atomically clear the play queue and add something to it.

Whay happens when playlists are updated while playing?

Especially the play queue...

I'll come back to that. Next thing is patterns.

So, they have measures. They have a thing saying at what time every measure starts. This is made by playing the song and pressing the space bar every measure.

Measure timing can be scaled or re-inputted at any time.

A list of measures shows on the side. A play button plays the relevant measure.

The entire song shows in a scroll pane, with rulers for the jets on the left and for the measures on the top.

Measures can be set to repeat N times, which logically shifts the rest of the song after it.

The song can also be shifted manually.

Measures don't all have to be the same length, and can be resized as needed to a particular number of seconds.

Display shows firings that start before the end of the viewport and also end after the start ofnthe viewport. Others are hidden to save time while redrawing.

Dragging the middle of a firing moves it; dragging up or down changes its track. Dragging right/left moves it. Overlaps are not allowed, and show right next to the would-be overlapped firing. Adjacent firings are internally merged when building the transition table, mentioned below.

Dragging the sides of a firing move its start and end point.

Three check boxes enable moving, changing start, and changing end, for firings that are too small to.be otherwise adjusted. A right-click menu allows adjusting the time manually.

Firings can belong to a class. The class specifies the duration of the firing, either in seconds or in measure beats. Unsure of what to do if altering a class duration would cause overlaps. For classed firings, resizers are disabled.

A grid, displayed in terms of fractions of a measure, can be displayed, and all firings aligned to it. Both start and end of a firing whose length is not a multiple of the grid size are snapped.

Display can be scaled in terms of measures or in terms of seconds.

Todo: see if there's anu open-source light show software, and see how it handles all of these issues.


























