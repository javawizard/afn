So, files have their own history.
And I'm referring to revision thingies with numbers, but they'd really be sha1 hashes.
So, there's a revision 1, which says "ohai, I'm creating a new file, and here's its contents". It doesn't say the name of the file or anything, though, it just says its contents.
Then there's another revision, 2, which says "ohai, I'm a modification to revision 1, and here's a diff of how I change the contents of revision 1's file".
And then you have folders, and they work similarly, but something like this, for revision 3:
"ohai, I'm a folder, and I contain a file named 'test.txt', whose contents are revision 1". The folder only mentions its child files' names, not its own name.
And then you'd have another folder revision, 4, which says "ohai, I'm a modification to revision 3, and the change I'm making is that my file named "test.txt" now has the contents of revision 2".
And in practice, revisions 1 and 3 would have been created at the same time, when you created the repository (which is, of course, a folder, that doesn't really need a name, cause it's the repository) and created test.txt in it. And 2 and 4 would have been created when you modified test.txt.
So in other words, whenever a file's modified, its parent folder gets a new revision saying that its version of the file is now the version at the file's new revision.
And child folders work the same way. Let's say that we go create a folder, "src", in the repository root, so it's beside test.txt, and we create a file named "stuff.py" in it.
What that'd do would go create revision 5, saying "ohai, I'm a file, and here are my initial contents, which are 'import x; import y; ...'". Then it'd go create revision 6, which says "ohai, I'm a new folder, and I contain a file named 'stuff.py' whose contents are revision 5". And then it'd go create a revision 7, which says "ohai, I'm a modification of revision 4, and the change I'm making is to add a new child folder named 'src' whose contents are revision 6".
So then any changes to files/folders/etc cause new revisions pointing to them to be created all the way up the tree.
And the glorious thing is that that provides automatic support for history tracking when files are renamed. Let's say we wanted to rename stuff.py to things.py. That'd be done by creating revision 8 which says "ohai, I'm a modification of revision 6, and my change is that I'm getting rid of my file named 'stuff.py', and I'm adding a file named 'things.py' whose contents are revision 5", and revision 9, which says "ohai, I'm a modification of revision 7, and my change is to change my file named 'src' to be revision 8".
So things.py's history is the same as stuff.py's history. And copies work the exact same way, by just having two filenames in different folders (or the same folder) point to the same file revision number.
And then submodules work by pulling in, say, revision 10 of http://example.com/awesomelib, and all of the history from that repo, and then creating a new revision, 11, which says "ohai, I'm a modification of revision 7, and my change is to add a new folder, whose name is 'awesomelib' and whose contents are revision 10". (How you'd actually do that from the command line would be a pull and then a merge, indicating that it's to be merged in as the folder awesomelib.)
And then you've made lots of changes to awesomelib locally, so that awesomelib is at revision 15, and the main repo is at revision 16, which just says "ohai, I'm a modification of revision N (where N is the former revision of the repository) and my change is to update 'awesomelib' to revision 15". So then you want to contribute the changes back, and all you have to do is push revision 15 and all of the revisions it's based on to http://example.com/awesomelib, not pushing revision 16 at all since that's your stuff, and then like, the authors of awesomelib merge 15 into their tree as usual and things are happy.
So yeah. That's all. ^_^
